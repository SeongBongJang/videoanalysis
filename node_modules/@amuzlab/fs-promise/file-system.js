'use strict'

const fs = require('fs');
require('graceful-fs').gracefulify(fs);
const path = require('path');
const readline = require('readline');
const os = require('os');
const utility = require('@amuzlab/utils');
const action = require('./action-util');

const EOL_REGEXP = /(?:\n|\r\n|\r)/g;

function _getTimeDiff (date1, date2){
    return Math.floor(utility.date.dateCompareTo(date1, date2, utility.date.CRITERIA.SECONDS));
}

exports.fs = fs;

exports.checkPath = function (filePath){
    return new Promise((resolve, reject) => (
        filePath = utility.path.normalizePath(filePath, __dirname),
        fs.stat(filePath, (err, stat) => !err ? resolve({
            filePath : filePath,
            stat: stat
        }) : reject(exports.errCtl(err)))));
};

/*
* listener
*   readFileOpen
*       - source 파일에 대한 readStream을 열었을 때의 이벤트
*       - event data
*           - data <Object>
*           - data.filePath <String> : source 파일 경로
*           - data.stat <fs.Stat> : source 파일 정보
*   writeFileOpen
*       - destination 파일에 대한 writeStream을 열었을 때의 이벤트
*       - event data
*           - destination <String> : destination 파일 경로
*   startCopyFile
*       - 복사가 시작했을 때의 이벤트
*       - event data
*           - data <Object>
*           - data.source <Object> : source 파일에 대한 정보
*           - data.fileName: source 파일명
*           - data.maxSize: source 파일 사이즈
*   data
*       - source 파일의 내용을 destination 파일로 복사하는 과정에서 초 단위로 이벤트를 발생하여 관련 데이터를 전달함
*       - event data
*           - data <Object>
*           - data.fileName <String> : source 파일명
*           - data.chunk <Buffer> : 복사 데이터
*           - data.percentAge <Number> : 현재까지의 진행률
*           - data.size <Number> : 현재까지 복사된 데이터 사이즈
*           - data.time <Number> : 현재까지 복사가 진행된 시간
*           - data.startTime <Date> : 복사 시작 시간
*           - data.speed <Number> : 복사 속도 (bytes / sec)
*   end
*       - 복사가 완료됐을 때의 이벤트
*       - event data
*           - data <Object>
*           - data.source <String> : source 파일 경로
*           - data.fileName: source 파일명
*           - data.destination: destination 파일 경로 (복사된 파일 경로)
*           - data.time: 복사하는데 걸린 시간
*           - data.size: 복사된 파일 사이즈
*           - data.totalSize: 총 파일 사이즈 (원본 파일 사이즈)
*           - data.percentAge: 완료된 상태의 진행률
*           - data.speed: 복사 속도
*           - data.startTime: 복사 시작 시간
*           - data.endTime: 복사 완료 시간
*   error
*       - 복사 도중 오류가 났을 경우의 이벤트
*       - event data
*           - err <Object>
*           - err.code <String> : 오류 코드
*           - [err.filePath] <String> : 오류 난 파일 경로
*           - err.message <String> : 오류 메시지
 */
exports.copyFile = function (source, destination, listeners){
    return Promise.all([
        exports.checkPath(source),
        exports.checkPath(path.dirname(destination))
        .catch(err => exports.mkdir(path.dirname(destination)))
    ])
        .then(result => new Promise((resolve, reject) => {
            const sourceFileInfo = result.shift();
            const destinationDirInfo = result.shift();
            destination = path.resolve(destinationDirInfo.filePath, destination);
            let size = 0;
            let startTime = new Date();
            let beforeTime = 0;
            let isError = false;

            const readStream = fs.createReadStream(sourceFileInfo.filePath)
                .on('open', () => action.callListener(listeners, 'readFileOpen', {
                    filePath: sourceFileInfo.filePath,
                    stat: sourceFileInfo.stat
                }))
                .on('end', () => writeStream.end())
                .on('data', chunk => {
                    size += chunk.length;
                    let _time = _getTimeDiff(new Date(), startTime);
                    let _progress;

                    size == 0 || size == sourceFileInfo.stat.size || (beforeTime < _time) ? (
                        _progress = {
                            fileName: path.basename(source),
                            chunk: chunk,
                            percentAge: size / sourceFileInfo.stat.size * 100,
                            size: size,
                            maxSize: sourceFileInfo.stat.size,
                            time: _time,
                            startTime: startTime,
                            speed: _time >= 1 ? size / _time : size
                        },
                        action.callListener(listeners, 'data', _progress),
                        beforeTime = _time) : null;
                })
                .on('error', err => (
                    isError = true,
                    readStream.close(),
                    err = exports.errCtl(err),
                    action.callListener(listeners, 'error', err),
                    reject(err)));

            const writeStream = fs.createWriteStream(destination)
                .on('open', () => action.callListener(listeners, 'writeFileOpen', destination))
                .on('pipe', source => action.callListener(listeners, 'startCopyFile', {
                    source: source,
                    fileName: path.basename(source.path),
                    maxSize: sourceFileInfo.stat.size
                }))
                .on('close', () => {
                    let endTime, _time, result;
                    isError ? null : (
                        endTime = new Date(),
                        _time = _getTimeDiff(endTime, startTime),
                        result = {
                            source: sourceFileInfo.filePath,
                            fileName: path.basename(source),
                            destination: destination,
                            time: _time,
                            size: size,
                            totalSize: sourceFileInfo.stat.size,
                            percentAge: size / sourceFileInfo.stat.size * 100,
                            speed: _time >= 1 ? size / _time : size,
                            startTime: startTime,
                            endTime: endTime
                        },
                        action.callListener(listeners, 'end', result),
                        resolve(result));
                })
                .on('error', err => (
                    err = exports.errCtl(err),
                    action.callListener(listeners, 'error', err),
                    reject(err)))
            readStream.pipe(writeStream);
        }));
};

exports.copyFiles = function (files, listeners){
    return new Promise((resolve, reject) => {
        let i, result;
        files ? (
            i = 0,
            result = {
                startTime: new Date(),
                time: 0,
				files: [],
				totalSize: 0,
				size: 0,
				currentCount: 0,
				totalCount: files.length,
				fileNames: Array.from(files, _file => path.basename(_file.source))
			},

            Promise.all(Array.from(files, _file => exports.checkPath(_file.source)))
            .then(results => (
                result.totalSize = results.reduce((totalSize, result) => totalSize + result.stat.size, 0),
                action.callListener(listeners, 'startCopyFiles', {
                    totalSize: result.totalSize,
                    startTime: result.startTime,
                    time: result.time,
                    files: Array.from(
                        files,
                        (_file, _index) => Object.assign(
                            {},
                            _file,
                            {size: results[_index].stat.size}))})))
            .then(() => (function _copyFile(file){
                file ? (
                    result.currentCount++,
                    exports.copyFile(
                        file.source,
                        file.destination,
                        Object.assign(
                            {},
                            listeners,
                            {
                                end: null,
                                data: data => (
                                    result.time = _getTimeDiff(new Date(), result.startTime),
                                    result.percentAge = (result.size + data.size) / result.totalSize * 100,
                                    result.speed = data.speed,
                                    action.callListener(listeners, 'data', {
                                        current: data,
                                        total: Object.assign(
                                            {},
                                            result,
                                            {size: result.size + data.size})}))}))
                    .then(_result => (
                        result.size += _result.size,
                        result.percentAge = result.size / result.totalSize,
                        result.files.push(_result),

                        action.callListener(listeners, 'end', Object.assign(_result, {
                            percentAge: result.percentAge,
                            currentCount: result.currentCount,
                            totalCount: result.totalCount
                        })),

                        _copyFile(files[i++])))
                    .catch(err => reject(err))) : (
                        result.endTime = new Date(),
                        result.time = _getTimeDiff(result.endTime, result.startTime),
                        result.percentAge = result.size / result.totalSize * 100,
                        resolve(result));
            })(files[i++]))
            .catch(err => reject(err))) : reject(new Error('files가 undefined 또는 null입니다.'));
    });
};

exports.mkdir = function (dirPath){
    return exports.checkPath(path.dirname(dirPath))
        .catch(err => {
            err = exports.errCtl(err);
            if(err.code == 'E102'){
                return exports.mkdir(path.dirname(dirPath));
            }else{
                throw err;
            }
        })
        .then(result =>
            new Promise((resolve, reject) =>
                fs.stat(dirPath, (err, stat) =>
                    err ? (
                        err = exports.errCtl(err),
                        err.code == 'E102' ? fs.mkdir(
                            dirPath,
                            err => !err ? resolve(dirPath) : (
                                err = exports.errCtl(err),
                                err.code === 'E101' ? resolve(dirPath) : reject(err))) : (err.code === 'E101' ? resolve(dirPath) : reject(err)))
                    : resolve(dirPath))));
};

exports.readdir = function (dirPath){
    return exports.checkPath(path.dirname(dirPath))
        .then(result => new Promise((resolve, reject) => {
            fs.readdir(
                dirPath,
                (err, files) => err ? reject(exports.errCtl(err)) : resolve({
                    path: dirPath,
                    files: files
                }))
        }));
}

exports.rmdir = function (dirPath){
    return exports.readdir(dirPath)
        .then(result => Promise.all(
            result.files.map(_path => new Promise((resolve, reject) => {
                let _subPath = path.join(result.path, _path);
                fs.stat(
                    _subPath,
                    (err, stat) => stat.isDirectory() ? resolve(exports.rmdir(_subPath)) : fs.unlink(_subPath, err => !err ? resolve() : reject(exports.errCtl(err))));
            }))))
        .then(result =>
            new Promise((resolve, reject) => fs.rmdir(
                dirPath,
                err => !err ? resolve(dirPath) : (
                    err = exports.errCtl(err),
                    err.code === 'E102' ? resolve(dirPath) : reject(err)))));
};

exports.readFile = function (filePath, option){
    return exports.checkPath(filePath)
        .then(() => new Promise((resolve, reject) => (
            fs.readFile(
                filePath,
                option,
                (err, data) => err ? reject(exports.errCtl(err, filePath)) : resolve({
                    filePath: filePath,
                    data: data
                })))));
};

exports.writeFile = function (filePath, data, option){
    return exports.mkdir(path.dirname(filePath))
        .then(result =>
            new Promise((resolve, reject) =>
                fs.writeFile(
                    filePath,
                    data,
                    option,
                    err => err ? reject(exports.errCtl(err)) : resolve(filePath))))
};

exports.overrite = function (filePath, callback, encoding){
    return typeof callback === 'function' ? exports.readFile(filePath, typeof encoding === 'string' ? encoding : null)
        .then(data => exports.writeFile(filePath, callback(data, filePath))) : Promise.reject(new Error('callback이 function 타입이 아닙니다.'));
};

exports.readLine = function (filePath, option){
    let start = 0, count = 0, result = [], fileLineReader, curLineCount = 0, readStream;
    option && typeof option === 'object' ? (
        typeof option.start === 'number' && option.start >= 0 ? start = option.start : null,
        typeof option.count === 'number' && option.count >= 0 ? count = option.count : null) : null;

    return exports.checkPath(filePath)
        .then(() => new Promise((resolve, reject) => (
	    readStream = fs.createReadStream(filePath)
		.on('close', () => resolve({
		    filePath: filePath,
		    result: result
		})),
            fileLineReader = readline.createInterface({
		input: readStream
            })
            .on('line', data => (
                curLineCount++,
                result.length < count || !count ? (curLineCount >= start ? result.push(data) : null) : fileLineReader.close()
            ))
	    .on('close', () => readStream.close())
            .on('error', err => reject(exports.errCtl(err))))
        ));
};

/*exports.readLine = function (filePath, option){
    let start = 0, count = 0, result = [], curLineCount = 0;
    option && typeof option === 'object' ? (
        typeof option.start === 'number' && option.start >= 0 ? start = option.start : null,
        typeof option.count === 'number' && option.count >= 0 ? count = option.count : null) : null;

    return exports.readFile(filePath)
	.then(_result => ({
	    filePath: filePath,
	    result: _result.data === '' ? result : _result.data
		.split(EOL_REGEXP)
		.filter((line, index) => (
		    curLineCount = index + 1,
		    line !== '' && start <= curLineCount && curLineCount < start + count
		))
	}))
};*/

function _getFilter (target){
    let filter;

    switch(true){
        case typeof target === 'number':
            filter = (line, curLineNumber) => (target !== curLineNumber);
            break;
        case typeof target === 'string':
            filter = line => (target !== line);
            break;
        case target instanceof RegExp:
            filter = line => !target.test(line);
            break;
        case Array.isArray(target):
            filter = (line, curLineNumber) => !target.some(targetElement => {
                let result;

                switch(true){
                    case typeof targetElement === 'number':
                        result = targetElement === curLineNumber;
                        break;
                    case typeof targetElement === 'string':
                        result = targetElement === line;
                        break;
                    case targetElement instanceof RegExp:
                        result = targetElement.test(line);
                        break;
                }

                return result;
            });
            break;
    }

    return filter;
}

exports.removeLineSync = function (filePath, target, encoding){
    let data, lines, filter, ignores = [], curLineNumber;

    try{
        fs.statSync(filePath);
        data = fs.readFileSync(filePath, {
            encoding: typeof encoding === 'string' ? encoding : 'utf8'
        });
        return data === '' || (filter = _getFilter(target), typeof filter !== 'function') ? ({
            filePath: filePath,
            result: []
        }) : (
            lines = data.split(EOL_REGEXP).filter((line, index) => (
                curLineNumber = index + 1,
                filter(line, curLineNumber) ? true : (
                    ignores.push({
                        lineNumber: curLineNumber,
                        line: line
                    }),
                    false
                )
            )),
            fs.writeFileSync(filePath, lines.join(os.EOL)),
            {
                filePath: filePath,
                result: ignores
            }
        )
    }catch(err){
        throw exports.errCtl(err);
    }
};

exports.removeLine = function (filePath, target){
    let fileLineReader, writeStream, fileName, dirPath, tempFilePath, curLineNumber = 0, isRename = true, err, filter, ignores = [];

    return exports.checkPath(filePath)
        .then(() => (filter = _getFilter(target), typeof filter === 'function') ? (
            fileName = path.basename(filePath),
            dirPath = path.dirname(filePath),
            tempFilePath = path.join(dirPath, `${fileName}.tmp`),
            new Promise((resolve, reject) => (
                writeStream = fs.createWriteStream(tempFilePath)
                .on('close', () => isRename ? fs.rename(
                    tempFilePath,
                    filePath,
                    err => err ? reject(exports.errCtl(err)) : resolve({
                        filePath: filePath,
                        result: ignores
                    })) : fs.unlink(tempFilePath, _err => reject(exports.errCtl(_err ? _err : err))))
                .on('error', err => reject(exports.errCtl(err))),

                fileLineReader = readline.createInterface({
                    input: fs.createReadStream(filePath)
                })
                .on('line', line => (
                    curLineNumber++,
                    filter(line, curLineNumber) ? writeStream.write(line + os.EOL) : ignores.push({
                        lineNumber: curLineNumber,
                        line: line
                    })
                ))
                .on('close', () => writeStream.end())
                .on('error', _err => (
                    isRename = false,
                    writeStream.end(),
                    err = _err))
            ))) : Promise.resolve({
                filePath: filePath,
                result: []
            }));
};

exports.addLine = function (filePath, line){
	return typeof line === 'string' ? exports.checkPath(filePath)
        .catch(err => {
            if(err.code !== 'E102'){
                throw err;
            }
		})
		.then(() => new Promise((resolve, reject) => fs.writeFile(
			filePath,
			EOL_REGEXP.test(line) ? line : line + os.EOL,
			{
				flag: 'a+'
			},
			err => err ? reject(exports.errCtl(err)) : resolve({
				filePath: filePath,
				result: line
			})
		))) : Promise.reject(new Error('line이 문자열이 아닙니다.'));
};

exports.rename = function (oldPath, newPath){
    return exports.checkPath(oldPath)
        .then(() => exports.mkdir(path.dirname(newPath))
            .then(() => new Promise((resolve, reject) => fs.rename(
                oldPath,
                newPath,
                err => err ? reject(exports.errCtl(err)) : resolve({
                    oldPath: oldPath,
                    newPath: newPath})))));
};

exports.errCtl = function (err, filePath){
    switch(err.code){
        case 'EACCES':
            err = {
                code: 'E101',
                filePath: err.path,
                message: `${err.path} 에 대한 권한이 없습니다.`
            }
        case 'E101':
            break;
        case 'EEXIST':
            err = {
                code: 'E101',
                filePath: err.path,
                message: `${err.path} 가 이미 있습니다.`
            };
        case 'E101':
            break;
        case 'ENOENT':
            err = {
                code: 'E102',
                filePath: err.path,
                message: `${err.path} 가 없습니다.`
            };
        case 'E102':
			break;
        case 'EISDIR':
			err = {
                code: 'E103',
                filePath: filePath,
				message: `${typeof err.path === 'string' ? err.path : filePath} 가 디렉토리입니다.`
            };
        case 'E103':
			break;
        default:
            err = {
                code: 'E100',
                message: `파일 처리중 오류가 발생했습니다. message : ${err.message}`
            };
    }

    return err;
};
