'use strict'

const Client = require('ftp'),
    path = require('path'),
    fs = require('fs'),

    DEFAULT = require('./default'),
    ERROR = require('./error'),
    STATUS = require('./status'),

    validation = require('./validation'),
    Stat = require('./Stat')

/**
 * @alias       ftp-client~FtpClient
 * @classdesc   FTP 서버와의 연결을 관리하고 FTP Client의 기능을 수행하는 class
 * @extends     events
 * @since       0.0.1
 * @author      예장해
 * @date        2019-01-23
 * @see         {@link https://www.npmjs.com/package/ftp ftp-0.3.10}
 * @see         {@link https://tools.ietf.org/html/rfc959 RFC959(ftp)}
 * @requires    {@link https://nodejs.org/en/docs/ Node.js 0.10.x 이상 버전}
 * @requires    {@link https://www.npmjs.com/package/ftp ftp}
 * @requires    {@link module:sourceType sourceType}
 * @requires    {@link module:error error}
 * @requires    {@link module:default default}
 * @requires    {@link module:status status}
 * @requires    {@link module:validation validation}
 * @requires    {@link ftp-client~Stat Stat}
*/
class FtpClient extends require('events') {
    /**
     * @param       {Object=}   config                              - FTP 접속 설정 데이터
     * @param       {Object=}   [config.host=127.0.0.1]             - FTP 서버 IP address 또는 도메인
     * @param       {Object=}   [config.port=21]                    - FTP 서버 접속 포트
     * @param       {Object=}   [config.secure=false]               - FTP 접속 시, 보안 기능 사용 유무
     * @param       {Object=}   [config.secureOptions=undefined]    - FTP 접속 보안 기능 사용 시의 옵션
     * @param       {Object=}   [config.user=anonymous]             - FTP 서버 접속 계정
     * @param       {Object=}   [config.password=anonymous@]        - FTP 서버 접속 계정 비밀번호
     * @param       {Object=}   [config.connTimeout=10000]          - FTP 접속 타임 아웃 (milliseconds)
     * @param       {Object=}   [config.pasvTimeout=10000]          - FTP 접속 타임 아웃 (milliseconds)
     * @param       {Object=}   [config.keepalive=10000]            - FTP 접속 유지를 위한 noop 주기 (milliseconds)
     * @param       {Object=}   [config.clearFailCountTime=1000]    - FTP 접속 오류 후, 재연결 하고 에러 상태가 클리어 되는 시간 (milliseconds)
     * @param       {Object=}   [config.retryCount=0]               - FTP 접속 오류 후 재연결 시도 횟수<br/>
     *                                                                실패 개수가 retryCount보다 많아지면 에러 발생<br/>
     *                                                                연결 시도는 계속 유지<br/>
     *                                                                0으로 세팅되면 재시도 안함
     * @param       {Object=}   [config.retryInterval=1000]         - FTP 접속 오류 후 재연결 시도 간격 (milliseconds)
     * @param       {Boolean=}  [config.isConnect=false]            - FtpClient 인스턴스가 생성될 때 바로 컨넥션을 맺는지 여부
    */
    constructor (config) {
        super()

        if (!config) {
            config = {}
        }

        Object.defineProperties(
            this,
            {
                /**
                 * @member      {Object}                    _config                 - ftp 클라이언트 설정
                 * @memberof    ftp-client~FtpClient
                 * @private
                 * @instance
                 * @since       0.0.1
                 * @author      예장해
                 * @date        2019-01-23
                */
                _config: {
                    enumerable: true,
                    writable: true
                },
                /**
                 * @member      {Client}                    _client                 - ftp 모듈의 클라이언트 인스턴스
                 * @memberof    ftp-client~FtpClient
                 * @private
                 * @instance
                 * @since       0.0.1
                 * @author      예장해
                 * @date        2019-01-23
                */
                _client: {
                    writable: true
                },
                /**
                 * @member      {Integer}                   _failCount              - ftp 컨넥션 실패 카운트
                 * @memberof    ftp-client~FtpClient
                 * @private
                 * @instance
                 * @since       0.0.1
                 * @author      예장해
                 * @date        2019-01-23
                */
                _failCount: {
                    enumerable: true,
                    writable: true,
                    value: 0
                },
                /**
                 * @member      {module:status}             _status                 - ftp 연결 상태
                 * @memberof    ftp-client~FtpClient
                 * @private
                 * @instance
                 * @since       0.0.1
                 * @author      예장해
                 * @date        2019-01-23
                */
                _status: {
                    enumerable: true,
                    writable: true,
                    value: STATUS.DISCONNECTED
                },
                /**
                 * @member      {Integer}                   _checkStatusTimeout     - FTP와 연결 상태를 주기적으로 체크하는 타임아웃 객체
                 * @memberof    ftp-client~FtpClient
                 * @private
                 * @instance
                 * @since       0.0.1
                 * @author      예장해
                 * @date        2019-01-23
                */
                _checkStatusTimeout: {
                    writable: true,
                    value: null
                },
                /**
                 * @member      {String}                   _keepAliveTimeout        - FTP 서버에 접속했을 때, FTP 서버에서 보내주는 메시지
                 * @memberof    ftp-client~FtpClient
                 * @private
                 * @instance
                 * @since       1.0.6
                 * @author      예장해
                 * @date        2019-11-01
                */
                _keepAliveTimeout: {
                    writable: true,
                    value: null
                },
                /**
                 * @member      {String}                   _serverMessage           - FTP 서버에 접속했을 때, FTP 서버에서 보내주는 메시지
                 * @memberof    ftp-client~FtpClient
                 * @private
                 * @instance
                 * @since       0.0.1
                 * @author      예장해
                 * @date        2019-01-23
                */
                _serverMessage: {
                    writable: true,
                    value: null
                },
                /**
                 * @member      {Error}                   _err                      - FTP 에러
                 * @memberof    ftp-client~FtpClient
                 * @private
                 * @instance
                 * @since       0.0.1
                 * @author      예장해
                 * @date        2019-01-23
                */
                _err: {
                    writable: true,
                    value: null
                }
            })

        this.config = config

        if (this.config.isConnect) {
            this.connect()
                .catch(err => {})
        }
    }

    /**
     * @name        ftp-client~FtpClient#set:config
     * @function
     * @instance
     * @public
     * @desc        전달된 설정 데이터를 FtpClient 인스턴스에 세팅<br/>
     *              세팅되지 않은 값은 모듈 내 기본값으로 세팅
     * @param       {Object=}    config     - FTP 접속 설정 데이터 constructor parameter 참조<br/>
     *                                        전달된 값이 없으면 세팅하지 않음
     * @since       0.0.1
     * @author      예장해
     * @date        2019-01-23
     * @see         {@link ftp-client~FtpClient FtpClient constructor}
     * @see         {@link module:default default}
     * @example
     * const FtpClient = require('FtpClient'),
     *       ftpClient = new FtpClient()
     *
     * ftpClient.config = {host: '192.168.0.10', port: 21}
    */
    set config (config) {
        let attrName, obj, value

        if (config) {
            // 기본값 세팅
            for (attrName in DEFAULT) {
                obj = DEFAULT[attrName]
                value = config[obj.attrName]

                switch (obj.type) {
                    case 'string':
                    case 'boolean':
                    case 'object':
                        config[obj.attrName] = typeof value === obj.type ? config[obj.attrName] : obj.value
                        break
                    case 'integer':
                        if (
                            !Number.isInteger(value) ||
                            (
                                Number.isInteger(value) &&
                                Array.isArray(obj.range) && (
                                    (typeof obj.range[0] === 'number' && obj.range[0] > value) ||
                                    (typeof obj.range[1] === 'number' && value > obj.range[1])))) {
                            config[obj.attrName] = obj.value
                        }
                        break
                }
            }

            this._config = config
        }
    }

    /**
     * @name        ftp-client~FtpClient#get:config
     * @function
     * @instance
     * @public
     * @desc        설정 값을 리턴
     * @return      {Object}    설정값
     * @since       0.0.1
     * @author      예장해
     * @date        2019-01-23
     * @see         {@link ftp-client~FtpClient FtpClient constructor}
     * @see         {@link module:default default}
     * @example
     * const FtpClient = require('FtpClient'),
     *       ftpClient = new FtpClient({host: '192.168.0.10', port: 21})
     *
     * console.log(ftpClient.config)
     * // {
     * //       host: '192.168.0.10',
     * //       port: 21,
     * //       secure: false,
     * //       secureOptions: undefined,
     * //       user: 'anonymous',
     * //       password: 'anonymous@',
     * //       connTimeout: 10000,
     * //       pasvTimout: 10000,
     * //       keepalive: 10000,
     * //       clearFailCountTime: 1000,
     * //       retryCount: 0,
     * //       retryInterval: 1000
     * // }
    */
    get config () {
        return this._config
    }

    /**
     * @name        ftp-client~FtpClient#get:_clearFailCountTime
     * @function
     * @instance
     * @public
     * @desc        failCount 클리어 시간을 리턴
     * @return      {Integer}       failCount 클리어 시간
     * @since       0.0.1
     * @author      예장해
     * @date        2019-01-23
     * @example
     * const FtpClient = require('FtpClient'),
     *       ftpClient = new FtpClient({clearFailCountTime: 2000})
     *
     * console.log(ftpClient._clearFailCountTime)   // 2000
    */
    get _clearFailCountTime () {
        return Number.isInteger(this.config.clearFailCountTime) ? this.config.clearFailCountTime : DEFAULT.CLEAR_FAIL_COUNT_TIME.value
    }

    /**
     * @name        ftp-client~FtpClient#set:client
     * @function
     * @instance
     * @public
     * @desc        ftp 모듈의 클라이언트 instance를 세팅
     * @param       {ftp}   client  - ftp 모듈의 클라이언트 instance
     * @since       0.0.1
     * @author      예장해
     * @date        2019-01-23
     * @example
     * const FtpClient = require('FtpClient'),
     *       Client = require('ftp'),
     *       ftpClient = new FtpClient()
     *
     * ftpClient.client = new Client()
    */
    set client (client) {
        if (client) {
            this._client = client
            this._client
                .on(
                    'ready',
                    () => {
                        this.status = STATUS.CONNECTED

                        // FTP 서버와 접속 됐을 때, clearFailCountTime 시간 만큼 연결이 유지되면 failCount를 0 으로 초기화한다.
                        if (this._failCount > 0) {
                            this._clearFailCountTimeout = setTimeout(
                                () => this.clearFailCount(),
                                this._clearFailCountTime)
                        }
                    })
                .on(
                    'greeting',
                    serverMessage => this._serverMessage = serverMessage)
//                .on(
//                    'end',
//                    () => console.log('end'))
                .on(
                    'close',
                    hadErr => {
                        clearTimeout(this._clearFailCountTimeout)

                        if (this.status === STATUS.DISCONNECTING) {
                            // 정상적인 컨넥션 종료
                            this.status = STATUS.DISCONNECTED
                        } else {
                            // 비정상적인 컨넥션 종료
                            this._failCount++;

                            // 에러 이벤트 호출
                            if (this.status !== STATUS.ERROR) {
                                this.status = STATUS.ERROR
                            }

                            if (this._failCount > this.config.retryCount) {
                                this.emit('reconnectFail', this._err, this._failCount, this.config, this)
                            }

                            // ERROR 상태가 아니라면 재접속 상태 유지
                            //if (this.status !== STATUS.ERROR) {
                            //    this.status = STATUS.RECONNECTING
                            //}

                            setTimeout(
                                () => {
                                    this.emit('reconnecting', this._failCount, this.config, this)
                                    this.connect()
                                        .catch(err => {})
                                },
                                this.config.retryInterval)
                        }
                    })
                .on(
                    'error',
                    err => {
                        this._err = ERROR.getErrorCode(err)
                    })
        }
    }

    /**
     * @name        ftp-client~FtpClient#get:status
     * @function
     * @instance
     * @public
     * @desc        FtpClient instance의 상태를 리턴
     * @return      {module:status}       FtpClient instance의 상태
     * @since       0.0.1
     * @author      예장해
     * @date        2019-01-23
     * @example
     * const FtpClient = require('FtpClient'),
     *       STATUS = require('status'),
     *       ftpClient = new FtpClient()
     *
     * ftpClient.on('connect', (serverMessage, config, instance) => console.log(ftpClient.status)) // STATUS.CONNECTED
     *
     * console.log(ftpClient.status)   // STATUS.DISCONNECTED
     *
     * ftpClient.connect()
     * console.log(ftpClient.status)   // STATUS.CONNECTING
    */
    get status () {
        return this._status
    }

    /**
     * @name        ftp-client~FtpClient#set:status
     * @function
     * @instance
     * @public
     * @desc        FtpClient instance의 상태를 세팅 및 이벤트 발생
     * @param       {module:status}       FtpClient instance의 상태
     * @since       0.0.1
     * @author      예장해
     * @date        2019-01-23
     * @example
     * const FtpClient = require('FtpClient'),
     *       STATUS = require('status'),
     *       ftpClient = new FtpClient()
     *
     * ftpClient.on('connect', (serverMessage, config, instance) => console.log('connected'))  // connected 출력
     * ftpClient.status = STATUS.CONNECTED
    */
    set status (status) {
        if (this.status !== status) {
            this._status = status

            switch (this._status) {
                case STATUS.CONNECTED:
                    checkAlive.call(this)
                    /**
                     * @event   ftp-client~FtpClient#connect
                     * @desc    FTP 서버와 연결 됐을 때 발생하는 이벤트
                     * @param   {String}                serverMessage   - FTP 서버에 접속하면 전송되는 서버 메시지
                     * @param   {Object}                config          - {@link ftp-client~FtpClient 설정 데이터}
                     * @param   {ftp-client~FtpClient}  instance        - FtpClient의 instance
                     * @since   0.0.1
                     * @author  예장해
                     * @date    2019-01-23
                     * @see     {@link ftp-client~FtpClient FtpClient}
                    */
                    this.emit('connect', this._serverMessage, this.config, this)
                    break
                case STATUS.CONNECTING:
                    /**
                     * @event   ftp-client~FtpClient#connecting
                     * @desc    FTP 서버와 연결을 시도할 때 발생하는 이벤트
                     * @param   {Object}                config          - {@link ftp-client~FtpClient 설정 데이터}
                     * @param   {ftp-client~FtpClient}  instance        - FtpClient의 instance
                     * @since   0.0.1
                     * @author  예장해
                     * @date    2019-01-23
                     * @see     {@link ftp-client~FtpClient FtpClient}
                    */
                    this.emit('connecting', this.config, this)
                    break
                case STATUS.DISCONNECTED:
                    clearTimeout(this._keepAliveTimeout)
                    this._client = null
                    /**
                     * @event   ftp-client~FtpClient#disconnect
                     * @desc    FTP 서버와 연결이 끊어졌을 때 발생하는 이벤트<br/>
                     *          {@link ftp-client~FtpClient#_client _client}  속성 값을 null 처리하여 클리어
                     * @param   {Object}                config          - {@link ftp-client~FtpClient 설정 데이터}
                     * @param   {ftp-client~FtpClient}  instance        - FtpClient의 instance
                     * @since   0.0.1
                     * @author  예장해
                     * @date    2019-01-23
                     * @see     {@link ftp-client~FtpClient FtpClient}
                    */
                    this.emit('disconnect', this.config, this)
                    break
                case STATUS.DISCONNECTING:
                    clearTimeout(this._checkStatusTimeout)
                    this._checkStatusTimeout = null
                    this._serverMessage = null
                    /**
                     * @event   ftp-client~FtpClient#disconnecting
                     * @desc    FTP 서버와 연결을 끊을 때 발생하는 이벤트<br/>
                     *          {@link ftp-client~FtpClient#_checkStatusTimeout _checkStatusTimeout},
                     *          {@link ftp-client~FtpClient#_serverMessage _serverMessage} 속성값을 null 처리하여 클리어
                     * @param   {Object}                config          - {@link ftp-client~FtpClient 설정 데이터}
                     * @param   {ftp-client~FtpClient}  instance        - FtpClient의 instance
                     * @since   0.0.1
                     * @author  예장해
                     * @date    2019-01-23
                     * @see     {@link ftp-client~FtpClient FtpClient}
                    */
                    this.emit('disconnecting', this.config, this)
                    break
                case STATUS.ERROR:
                    clearTimeout(this._keepAliveTimeout)
                    /**
                     * @event   ftp-client~FtpClient#error
                     * @desc    오류 발생시 발생하는 이벤트
                     * @param   {Error}                 err             - {@link ftp-client~FtpClient FtpClient 에러}
                     * @param   {Object}                config          - {@link ftp-client~FtpClient 설정 데이터}
                     * @param   {ftp-client~FtpClient}  instance        - FtpClient의 instance
                     * @since   0.0.1
                     * @author  예장해
                     * @date    2019-01-23
                     * @see     {@link ftp-client~FtpClient FtpClient}
                    */
                    this.emit('error', this._err, this.config, this)
                    break
                case STATUS.RECONNECTING:
                    /**
                     * @event   ftp-client~FtpClient#reconnecting
                     * @desc    연결이 끊어진 후, 재연결 시도할 때 발생하는 이벤트
                     * @param   {Integer}               failCount       - {@link ftp-client~FtpClient#_failCount 실패 횟수}
                     * @param   {Object}                config          - {@link ftp-client~FtpClient 설정 데이터}
                     * @param   {ftp-client~FtpClient}  instance        - FtpClient의 instance
                     * @since   0.0.1
                     * @author  예장해
                     * @date    2019-01-23
                     * @see     {@link ftp-client~FtpClient FtpClient}
                    */
                    this.emit('reconnecting', this._failCount, this.config, this)
                    break
            }
        }
    }

    /**
     * @name        connect
     * @memberof    ftp-client~FtpClient
     * @function
     * @instance
     * @public
     * @desc        FTP 서버로 접속
     * @param       {Object}        FtpClient 모듈 설정 데이터
     * @return      {Promise<Boolean>}  접속된 상태인지 플래그 값을 리턴<br/>
     *                                  이미 접속된 상태였으면 false, 접속 되지 않았던 상태면 true 리턴
     * @throws      {Error}             ({@link module:error FtpClient 에러})
     * @since       0.0.1
     * @author      예장해
     * @date        2019-01-23
     * @see         {@link module:error error}
     * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise}
     * @example
     * const FtpClient = require('FtpClient'),
     *       STATUS = require('status'),
     *       ftpClient = new FtpClient(),
     *       ftpClient2 = new FtpClient({host: '127.0.0.1', user: 'ftpuser', password: '1234'})
     *
     * ftpClient.on('connect', (serverMessage, config, instance) => console.log('connected'))   // connected 출력
     * ftpClient2.on('connect', (serverMessage, config, instance) => console.log('connected'))  // connected 출력
     * ftpClient.connect({host: '127.0.0.1', user: 'ftpuser', password: '1234'})                // 전달인자가 있는 경우
     * ftpClient2.connect()                                                                     // 전달 인자가 없는 경우
     *           .then(isAlreadyConnect => console.log('connect ', isAlreadyConnect))           // connect true 출력 (이미 접속 상태에서 connect 메소드가 호출됐다면 connect false 출력)
     *           .catch(err => console.error('connect error ', err))                            // 연결에 실패하면 에러 출력
    */
    connect (config) {
        return new Promise((resolve, reject) => {
            try {
                if (this.status === STATUS.CONNECTED) {
                    resolve(false)
                } else {
                    this.config = config
                    this.client = new Client()

                    this.once('connect', connectListener)
                    this._client.once('error', errorListener.bind(this))

                    if (this.status !== STATUS.ERROR && this.status !== STATUS.RECONNECTING) {
                        this.status = STATUS.CONNECTING
                    }

                    this._client.connect(this.config)
                }
            } catch (err) {
                this._client.removeListener('error', errorListener)
                this.removeListener('connect', connectListener)
                reject(ERROR.getErrorCode(err))
            }

            function connectListener (serverMessage, config, ftpClient) {
                this._client.removeListener('error', errorListener)
                resolve(true)
            }

            function errorListener (err) {
                this.removeListener('connect', connectListener)
                reject(ERROR.getErrorCode(err))
            }
        })
    }

    /**
     * @name        disconnect
     * @memberof    ftp-client~FtpClient
     * @function
     * @instance
     * @public
     * @desc        FTP 서버와 접속 종료
     * @return      {Promise}   전달인자 없음
     * @throws      {Error}             ({@link module:error FtpClient 에러})
     * @since       0.0.1
     * @author      예장해
     * @date        2019-01-23
     * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise}
     * @example
     * const FtpClient = require('FtpClient'),
     *       STATUS = require('status'),
     *       ftpClient = new FtpClient({host: '127.0.0.1', user: 'ftpuser', password: '1234'})
     *
     * ftpClient.on('connect', (serverMessage, config, instance) => (console.log('connected'), instance.disconnect()))      // connected 출력 후 접속 종료
     * ftpClient.on('disconnect', (serverMessage, config, instance) => console.log('disconnected'))                         // disconnected 출력
     * ftpClient.connect()
    */
    disconnect () {
        return new Promise((resolve, reject) => {
            try {
                if (this.status === STATUS.CONNECTED) {
                    this.once('disconnect', disconnectListener)
                    this.status = STATUS.DISCONNECTING
                    this._client.destroy()
                } else {
                    resolve()
                }

                function disconnectListener (config, ftpClient) {
                    resolve()
                }
            } catch (err) {
                reject(ERROR.getErrorCode(err))
            }
        })
    }

    /**
     * @name        clearFailCount
     * @memberof    ftp-client~FtpClient
     * @function
     * @instance
     * @public
     * @desc        failCount를 0으로 세팅<br/>
     *              기존의 failCount가 0이라면 이벤트가 발생하지 않음<br/>
     *              기존의 failCount가 0이 아니라면 failCount가 0으로 세팅되고 clearFailCount 이벤트 발생
     * @since       0.0.1
     * @author      예장해
     * @date        2019-01-23
     * @example
     * const FtpClient = require('FtpClient'),
     *       STATUS = require('status'),
     *       ftpClient = new FtpClient({host: '127.0.0.1', user: 'ftpuser', password: '1234'})
     *
     * ftpClient.on('clearFailCount', (config, instance) => console.log('clearFailCount failCount :', instance._failCount))      // clearFailCount failCount : 0 출력
     * ftpClient.clearFailCount()       // failCount가 0이면 이벤트 발생 안함
     * ftpClient._failCount = 1
     * ftpClient.clearFailCount()       // failCount가 0이 아니면 failCount를 0으로 세팅하고 이벤트 발생
    */
    clearFailCount () {
        let failCount = this._failCount

        this._failCount = 0

        if (failCount > 0) {
            this.emit('clearFailCount', this.config, this)
        }
    }

    /**
     * @name        mkdir
     * @memberof    ftp-client~FtpClient
     * @function
     * @instance
     * @public
     * @desc        접속한 FTP 서버에 디렉터리 생성
     * @param       {String}    dirPath     - FTP 서버에 생성할 디렉터리 경로
     * @return      {Promise<String>}       호출 시 전달된 전달인자
     * @throws      {Error}                 {@link module:error FtpClient 에러}
     * @since       0.0.1
     * @author      예장해
     * @date        2019-01-23
     * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise}
     * @example
     * const FtpClient = require('FtpClient'),
     *       ftpClient = new FtpClient({user: 'ftpuser', password: 'ftpuser'})
     *
     * ftpClient.connect()
     *          .then(() => mkdir('2019/01'))
     *          .then(dirPath => console.log(dirPath))      // 정상적으로 디렉터리가 생성된 경우 2019/01 출력
    */
    mkdir (dirPath) {
        return new Promise((resolve, reject) => {
            if (typeof dirPath === 'string') {
                this._client.mkdir(
                    validation.normalizePath(dirPath),
                    true,
                    err => err ? (
                        err = ERROR.getErrorCode(err),
                        err.dirPath = dirPath,
                        reject(err)) : resolve(dirPath))
            } else {
                reject(new Error('dirPath가 없습니다.'))
            }
        })
    }

    /**
     * @name        put
     * @memberof    ftp-client~FtpClient
     * @function
     * @instance
     * @public
     * @desc        접속한 FTP 서버에 파일 업로드<br/>
     *              putData.destination이 디렉터리 경로를 포함한 경우, FTP 서버에 해당 디렉터리 경로가 없으면 내부적으로 생성
     * @param       {Object}                        putData                         - FTP 서버에 업로드할 데이터
     * @param       {String|Buffer|ReadableStream}  putData.source                  - FTP 서버에 업로드할 입력 소스
     * @param       {module:ftp-client/sourceType}  putData.sourceType              - source 속성값의 타입
     *                                                                                <ul>
     *                                                                                  <li>FILE: 파일이 있는지 검사 후 업로드
     *                                                                                  <li>DEFAULT : {@link https://www.npmjs.com/package/ftp ftp} 모듈에 동작 위임 처리
     *                                                                                      <ul>
     *                                                                                          <li>source 값이 파일 경로인지 검사 후 파일이면 파일 업로드
     *                                                                                          <li>파일 경로가 아닌 String 또는 Buffer면 FTP에 source 내용으로 파일 생성
     *                                                                                          <li>ReadableStream의 경우, 파일 업로드
     *                                                                                      </ul>
     *                                                                              </ul>
     * @param       {String}                        putData.destination             - 업로드할 파일 경로
     * @param       {Boolean=}                      [putData.useCompression=false]  - 압축 사용<br/>
     *                                                                                라이브러리 미지원으로 사용 불가
     * @return      {Promise<String>}       호출 시 전달된 전달인자
     * @throws      {Error}                 {@link module:error FtpClient 에러}
     * @since       0.0.1
     * @author      예장해
     * @date        2019-01-23
     * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise}
     * @requires    {@link module:validation validation}
     * @todo        putData.useCompression 압축 옵션 구현
     * @todo        putData.destination이 없으면 source 파일명으로 업로드
     * @example
     * const FtpClient = require('FtpClient'),
     *       ftpClient = new FtpClient({user: 'ftpuser', password: 'ftpuser'})
     *
     * ftpClient.put({
     * source: '/data/img.jpg',
     *     sourceType: ftpClient.SOURCE_TYPE.FILE,
     *     destination: 'data/img.jpg'
     * })
     *     .then(result => console.log(result))
     *     .catch(err => console.error(err))
    */
    put (putData) {
        return new Promise((resolve, reject) => {
            if (putData && putData.source && putData.destination) {
                validation.isExistSource(putData)
                    .then(putData => this.mkdir(path.posix.dirname(putData.destination)))
                    .then(() => {
                        this._client.put(
                            putData.source,
                            validation.normalizePath(putData.destination),
                            putData.useCompression,
                            err => err ? reject(err) : resolve(putData))
                    })
                    .catch(err => reject(err))
            } else {
                reject(new Error('source 또는 destination이 없습니다.'))
            }
        })
    }

    /**
     * @typedef     {Object}                ftp-client~FtpClient~lsResult
     * @prop        {String}                searchPath  - 조회 경로
     * @prop        {ftp-client~Stat[]}     stats       - 조회 결과
     * @see         {@link ftp-client~Stat Stat}
    */

    /**
     * @name        ls
     * @memberof    ftp-client~FtpClient
     * @function
     * @instance
     * @public
     * @param       {String}    searchPath  - 조회할 파일 또는 디렉터리 경로
     * @return      {Promise<{ftp-client~FtpClient~lsResult}>}
     * @throws      {Error}                 {@link module:error FtpClient 에러}
     * @since       1.0.0
     * @author      예장해
     * @date        2019-02-06
     * @desc        전달된 경로에 있는 파일 또는 디렉터리 리스트를 조회
     * @see         {@link ftp-client~Stat Stat}
     * @todo        recursive 기능 구현
     * @example
     * const FtpClient = require('FtpClient'),
     * ftpClient = new FtpClient()
     *
     * ftpClient.ls('data')
     *     .then(lsResult => console.log(lsResult))
     *     .catch(err => console.error(err))
    */
    ls (searchPath) {
        return new Promise((resolve, reject) => {
            if (typeof searchPath === 'string') {
                this._client.list(
                    searchPath,
                    (err, list) => {
                        if (err) {
                            reject(ERROR.getErrorCode(err))
                        } else {
                            resolve({
                                searchPath: searchPath,
                                stats: list.map(stat => new Stat(stat))
                            })
                        }
                    })
            } else {
                reject(new Error('searchPath가 없습니다.'))
            }
        })
    }
}

/**
 * @name        checkAlive
 * @memberof    ftp-client~FtpClient
 * @function
 * @static
 * @private
 * @desc        keepalive 설정 주기 만큼 FTP 서버로 상태 정보를 폴링하여 연결 상태를 확인<br/>
 *              FTP 서버의 상태 정보를 못받아오면 timeout 에러 및 timeout 이벤트 발생
 * @since       0.0.1
 * @author      예장해
 * @date        2019-01-23
*/
function checkAlive () {
    // FTP 서버와 연결 상태 확인을 위해, keepalive에 설정된 시간 주기로 FTP 서버 상태 조회
    this._client.status(
        (err, status) => {
            if (!err) {
                clearTimeout(this._checkStatusTimeout)
                this._keepAliveTimeout = setTimeout(
                    () => {
                        checkAlive.call(this)
                    },
                    this.config.keepalive)
            }
        })

    // FTP 서버의 상태 정보를 가져오지 못하면 아래 로직이 수행되어 timeout 에러를 발생시킴
    this._checkStatusTimeout = setTimeout(
        () => {
            let interval, err

            /**
             * @event   ftp-client~FtpClient#timeout
             * @desc    FTP 서버와 연결 된 후, {@link ftp-client~FtpClient keepalive}에 설정된 시간 주기로 FTP 서버의 상태를 조회함으로써 연결을 체크<br/>
             *          keepalive 시간 동안 상태 체크에 대한 응답이 없는 경우 timeout 에러 및 이벤트 발생
             * @param   {Object}                config          - {@link ftp-client~FtpClient 설정 데이터}
             * @param   {ftp-client~FtpClient}  instance        - FtpClient의 instance
             * @since   0.0.1
             * @author  예장해
             * @date    2019-01-23
             * @see     {@link ftp-client~FtpClient FtpClient}
             */
            this.emit('timeout', this.config, this)
            // 타임 아웃이 발생하면 에러 발생 및 FTP 서버와 연결을 끊고 다시 연결 시도를 한다.
            this._client.destroy()
            // 타임아웃 에러 세팅 전에 close 이벤트가 발생하여 error 이벤트에서 Error 인스턴스를 못 받는 이슈 있음
            interval = setInterval(
                () => {
                    // 연결 상태를 체크하여 오류 발생
                    if (!(this._client && this._client.connected)) {
                        this._err = new Error('서버와 연결이 끊겼습니다.')
                        this._err.code = ERROR.ERROR_CODE.TIMEOUT

                        clearInterval(interval)
                    }
                },
                100)
        },
        this.config.keepalive)
}

module.exports = exports = FtpClient
