'use strict'

/**
 * @module      validation
 * @desc        ftp-client 모듚의 유효성 체크 모듈<br/>
 *              업로드(put) 대상에 대해 유효성을 검사<br/>
 *              FtpClient의 메소드들의 parameter로 전달된 경로들에 대해 정규화된 경로로 바꿈
 * @since       0.0.1
 * @author      예장해
 * @date        2019-01-23
 * @requires    {@link https://nodejs.org/en/docs/ Node.js 0.10.x 이상 버전}
 * @requires    {@link module:sourceType sourceType}
 * @requires    {@link module:error error}
*/

const path = require('path'),
    fs = require('fs'),

    SOURCE_TYPE = require('./sourceType'),
    ERROR = require('./error')

Object.defineProperties(
    exports,
    {
        /**
         * @name        isExistSource
         * @function
         * @static
         * @public
         * @desc        전달된 source (업로드할 대상)가 정상인지 판단
         * @since       0.0.1
         * @author      예장해
         * @date        2019-01-23
         * @param       {Object}                        putData                         - 파일 업로드시 전달된 데이터
         * @param       {String|Buffer|ReadableStream}  putData.source                  - FTP 서버에 업로드할 대상
         * @param       {module:sourceType}             putData.sourceType              - 업로드 대상의 타입
         *                                                                                <ul>
         *                                                                                  <li>FILE : 파일이 있는지 검사
         *                                                                                  <li>DEFAULT : {@link https://www.npmjs.com/package/ftp ftp} 모듈에 동작 위임 처리
         *                                                                                      <ul>
         *                                                                                          <li>source 값이 파일 경로인지 검사
         *                                                                                          <li>파일 경로가 아닌 String | Buffer 면 FTP에 source 내용으로 파일 생성
         *                                                                                          <li>ReadableStream의 경우, 파일 업로드
         *                                                                                      </ul>
         *                                                                                </ul>
         * @param       {String}                        putData.destination             - 업로드할 파일 경로
         * @param       {Boolean=}                      [putData.useCompression=false]  - 압축 사용<br/>
         *                                                                                라이브러리 미지원으로 사용 불가
         * @todo        putData.useCompression 압축 옵션 구현
         * @return      {Promise}   parameter로 전달된 putData
         * @throws      {Error}     {@link module:error error}에 정의된 에러
         * @throws      {Error}     putData가 없는 경우 에러
         * @example
         * const validation = require('validation'),
         *       SOURCE_TYPE = require('sourceType')
         *
         * // 업로드 대상의 타입을 파일로 지정한 경우
         * validation.isExistSource({
         *     source: '/data/input.jpg',
         *     sourceType: SOURCE_TYPE.FILE
         * })
         *     .then(putData => console.log(putData))    // putData.source가 존재하면 putData 리턴 {source: '/data/input.jpg', sourceType: SOURCE_TYPE.FILE}
         *     .catch(err => console.error(err))         // putData.source가 존재하지 않는 경우 에러
         *
         * // 업로드 대상의 타입을 지정하지 않은 경우 (SOURCE_TYPE.DEFAULT)
         * validation.isExistSource({
         *     source: '/data/input.jpg'
         * })
         *     .then(putData => console.log(putData))   // putData 리턴 (bypass) {source: '/data/input.jpg', sourceType: SOURCE_TYPE.FILE}
         *     .catch(err => console.error(err))        // putData가 없는 경우 에러
        */
        isExistSource: {
            value: putData => {
                return new Promise((resolve, reject) => {
                    switch (putData.sourceType) {
                        case SOURCE_TYPE.FILE:
                            fs.stat(
                                putData.source,
                                (err, stat) => err ? reject(err) : resolve(putData))
                            break
                        case SOURCE_TYPE.DEFAULT:
                        default:
                            resolve(putData)
                    }
                })
                    .catch(err => {
                        throw ERROR.getErrorCode(err)
                    })
            }
        },
        /**
         * @name        normalizePath
         * @function
         * @static
         * @public
         * @desc        parameter로 전달된 경로를 정규화된 경로로 바꿈
         * @since       0.0.1
         * @author      예장해
         * @date        2019-01-23
         * @param       {String|Buffer}    _path   정규화할 경로
         * @return      {String}    정규화된 경로
         * @throws      {Error}     전달된 경로가 String 또는 Buffer 타입이 아닌 경우
         * @example
         * const validation = require('validation')
         *
         * validation.normalizePath('/data/2019/01/a.jpg')                  // 'data/2019/01/a.jpg'
         * validation.normalizePath('data/2019/01/a.jpg')                   // 'data/2019/01/a.jpg'
         * validation.normalizePath('./data/2019/01/a.jpg')                 // 'data/2019/01/a.jpg'
         * validation.normalizePath(Buffer.from('/data/2019/01/a.jpg'))     // 'data/2019/01/a.jpg'
         * validation.normalizePath(Buffer.from('data/2019/01/a.jpg'))      // 'data/2019/01/a.jpg'
         * validation.normalizePath(Buffer.from('./data/2019/01/a.jpg'))    // 'data/2019/01/a.jpg'
        */
        normalizePath: {
            value: _path => {
                let isBuffer = false

                if (!(typeof _path === 'string' || (isBuffer = _path instanceof Buffer))) {
                    throw new Error(`전달된 경로가 String 타입 또는 Buffer 타입이 아닙니다. path : ${_path}`)
                }

                if (isBuffer) {
                    _path = _path.toString()
                }

                return path.posix.join('.', _path.replace(/^\//, ''))
            }
        }
    })
