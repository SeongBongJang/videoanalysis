'use strict'

const childProcess = require('child_process'),
    spawn = childProcess.spawn,
    exec = childProcess.exec,
    path = require('path'),
    fsPromise = require('@amuzlab/fs-promise'),

    DEFAULT = require('./default'),
    SIGNAL = require('./signal')

/** custom type definition **/
/**
 * @typedef     {Object}    Process~ProcessResult
 * @desc        process 종료 결과 데이터를 가지는 Object
 * @property    {Boolean}   killed  - api를 통해 process signal이 전달됐는지 여부
 * @property    {Number}    code    - process return code
 * @property    {String}    signal  - process에 전달된 signal
*/
class ProcessResult {
    constructor (killed, code, signal) {
        this.killed = killed
        this.code = code
        this.signal = signal
    }
}

/**
 * @typedef     {Object}    Process~CheckProcessResult
 * @desc        Process.checkProcess 결과 데이터를 가지는 Object
 * @property    {Number}            pid         - child process pid
 * @property    {String}            command     - child process binary path
 * @property    {Array<String>}     args        - exec arguments
*/


/** event definition **/
/**
 * @event   Process#command
 * @desc    child process가 실행될 때 발생되는 이벤트<br/>
 *          실행되는 명령줄이 parameter로 전달된다
 * @param   {String}            command     - 실행될 명령줄
 * @param   {Process}           instance        - this reference
*/
/**
 * @event   Process#exec
 * @desc    child process가 실행될 때 발생되는 이벤트
 * @param   {Process}           instance        - this reference
*/
/**
 * @event   Process#stop
 * @desc    process가 중지됐을 때 발생되는 이벤트
 * @param   {Process}           instance        - this reference
 * @param   {ProcessResult}     processResult   - process 종료 결과
 * @see     {@link Process~ProcessResult ProcessResult}
*/
/**
 * @event   Process#retryFail
 * @desc    process 비정상 종료시 재시도를 실패했을 때 발생되는 이벤트<br/>
 *          재시도 횟수가 config.retryCnt를 넘으면 재시도 실패<br/>
 *          config.retryCnt가 Infinity인 경우 재시도 실패는 없다
 * @param   {Integer}           retryCnt        - retry 횟수
 * @param   {Process}           instance        - this reference
*/
/**
 * @event   Process#retry
 * @desc    process 비정상 종료시 재시도를 할 때 발생되는 이벤트
 * @param   {Integer}           retryCnt        - retry 횟수
 * @param   {Process}           instance        - this reference
*/
/**
 * @event   Process#kill
 * @desc    process 정상 종료시 발생되는 이벤트
 * @param   {Process}           instance        - this reference
 * @param   {ProcessResult}     processResult   - process 종료 결과
 * @see     {@link Process~ProcessResult ProcessResult}
*/
/**
 * @event   Process#stderr
 * @desc    child process보부터 stderr 스트림으로 데이터가 전달되면 이벤트 발생
 * @param   {String}            stderr          - stderr 문자열
 * @param   {Process}           instance        - this reference
*/
/**
 * @event   Process#stdout
 * @desc    child process보부터 stdout 스트림으로 데이터가 전달되면 이벤트 발생
 * @param   {String}            stdout          - stdout 문자열
 * @param   {Process}           instance        - this reference
*/
/**
 * @event   Process#error
 * @desc    error 이벤트
 * @param   {Error}             err             - 발생한 error instance
 * @param   {Process}           instance        - this reference
*/
/**
 * @event   Process#createPidFile
 * @desc    pidFile 생성시 발생하는 이벤트
 * @param   {String}            pidFilePath     - pid file path
 * @param   {Process}           instance        - this reference
 * @param   {Error=}            err             - pid file 생성 실패시 발생한 Error instance
*/
/**
 * @event   Process#removePidFile
 * @desc    pidFile 제거시 발생하는 이벤트
 * @param   {String}            pidFilePath     - pid file path
 * @param   {Process}           instance        - this reference
 * @param   {Error=}            err             - pid file 제거 실패시 발생한 Error instance
*/


/** class definition **/
/**
 * @classdesc   child process life cycle을 관리하는 클래스<br/>
 *              Process 클래스를 상속받아 사용한다
 * @extends     EventEmitter
 * @since       0.0.1
 * @date        2019-12-30
 * @requires    {@link https://nodejs.org/en/docs/ Node.js 0.10.x 이상 버전}
 * @requires    {@link module:default default}
 * @requires    {@link module:siganl signal}
 * @see         {@link https://nodejs.org/docs/latest-v8.x/api/child_process.html#child_process_child_process_spawn_command_args_options child_process.spawn}
 * @see         {@link https://nodejs.org/docs/latest-v8.x/api/events.html#events_class_eventemitter EventEmitter}
*/
class Process extends require('events') {
    /**
     * @param       {String}                command                             - child process binary 경로
     * @param       {Object=}               config                              - child process 설정 정보
     * @param       {(Number|Infinity)=}    [config.retryCnt=3]                 - child process 비정상 종료시 재시도 횟수
     * @param       {Number=}               [config.retryInterval=1]            - child process 비정상 종료시 재시도 시간 (sec)
     * @param       {Object=}               config.env                          - child process 실행시 환경 세팅 값 (key-value)
     * @param       {String=}               config.cwd                          - child process의 current directory
     * @param       {Function=}             config.customError                  - error 발생시 사용자 정의 Error를 발생시킬 함수<br/>
     *                                                                            error 발생시 customError 함수를 호출하고 리턴된 값을 참조하여 사용자 정의 이벤트 발생
     * @param       {String=}               [config.stopSignal=SIGKILL]         - child process 종료 {@link module:signal signal}
     * @param       {Number=}               [config.successCode=0]              - child process 정상 종료 리턴 코드
     * @param       {String=}               [config.pidPath]                    - child process 실행시 pid 파일을 생성할 directory path<br/>
     *                                                                            absolute path가 아닌 경우 process.cwd를 기준으로 absolute path 생성<br/>
     *                                                                            pid 파일 형식 : PID.pid<br/>
     *                                                                            pidPath가 없으면 pid 파일을 생성하지 않는다
    */
    constructor (command, config) {
        super()

        Object.defineProperties(
            this,
            {
                /**
                 * @member      {String}        _command        - process binary 경로
                 * @memberof    Process
                 * @private
                 * @instance
                 * @since       0.0.1
                 * @date        2019-12-30
                */
                _command: {
                    writable: true,
                    value: command
                },
                /**
                 * @member      {Object}        _config         - process 설정 정보
                 * @memberof    Process
                 * @private
                 * @instance
                 * @since       0.0.1
                 * @date        2019-12-30
                */
                _config: {
                    writable: true,
                    value: config
                },
                /**
                 * @member      {ChildProcess}  _child          - child process instance
                 * @memberof    Process
                 * @private
                 * @instance
                 * @since       0.0.1
                 * @date        2019-12-30
                 * @see         {@link https://nodejs.org/docs/latest-v8.x/api/child_process.html#child_process_class_childprocess ChildProcess}
                */
                _child: {
                    writable: true,
                    value: null
                },
                /**
                 * @member      {Timeout}       _retryTimeout   - process 비정상 종료 후 retry 할 때, 내부에서 사용하는 retryInterval에 대한 timeout instance
                 * @memberof    Process
                 * @private
                 * @instance
                 * @since       0.0.1
                 * @date        2019-12-30
                 * @see         {@link https://nodejs.org/docs/latest-v8.x/api/timers.html#timers_class_timeout Timeout}
                */
                _retryTimeout: {
                    writable: true,
                    value: null
                }
            })

        this.config = config ? config : {}
    }

    /** abstract definition **/
    /**
     * @name        get:args
     * @memberof    Process
     * @abstract
     * @function
     * @instance
     * @public
     * @desc        child process 실행시 전달할 arguments 리스트를 리턴<br/>
     *              subclass에서 해당 메소드를 implementation하여 사용
     * @since       0.0.1
     * @date        2019-12-30
     * @returns     {Array<String>}     arguments list
    */

    /**
     * @name        parseStderr
     * @memberof    Process
     * @abstract
     * @function
     * @instance
     * @public
     * @desc        child process로부터 stderr로 전달된 데이터를 파싱하는 메소드<br/>
     *              subclass에서 해당 메소드를 implementation하여 사용
     * @param       {String}    stderr  - stderr
     * @since       0.0.1
     * @date        2019-12-30
    */

    /**
     * @name        parseStdout
     * @memberof    Process
     * @abstract
     * @function
     * @instance
     * @public
     * @desc        child process로부터 stdout으로 전달된 데이터를 파싱하는 메소드<br/>
     *              subclass에서 해당 메소드를 implementation하여 사용
     * @param       {String}    stdout  - stdout
     * @since       0.0.1
     * @date        2019-12-30
    */


    /**
     * @name        get:config
     * @memberof    Process
     * @function
     * @instance
     * @public
     * @desc        Process instance에 세팅된 설정 정보 리턴
     * @returns     {Object}    config
     * @since       0.0.1
     * @date        2019-12-30
     * @see         {@link Process Process constructor}
    */
    get config () {
        return this._config
    }

    /**
     * @name        set:config
     * @memberof    Process
     * @function
     * @instance
     * @public
     * @desc        전달된 설정 데이터를 Process 인스턴스에 세팅<br/>
     *              세팅되지 않은 값은 모듈 내 기본값으로 세팅
     * @param       {Object=}    config     - process 설정 정보 constructor parameter 참조
     * @since       0.0.1
     * @date        2019-12-30
     * @see         {@link Process Process constructor}
     * @see         {@link module:default default}
    */
    set config (config) {
        if (config) {
            typeof config.retryCnt !== 'number' && (config.retryCnt = DEFAULT.RETRY_CNT)
            typeof config.retryInterval !== 'number' && (config.retryInterval = DEFAULT.RETRY_INTERVAL)
            typeof config.stopSignal !== 'string' && (config.stopSignal = DEFAULT.STOP_SIGNAL)
            typeof config.successCode !== 'number' && (config.successCode = DEFAULT.SUCCESS_CODE)
            typeof config.pidPath === 'string' && !path.isAbsolute(config.pidPath) && (config.pidPath = path.resolve(config.pidPath))

            this._config = config
        }
    }

    /**
     * @name        get:command
     * @memberof    Process
     * @function
     * @instance
     * @public
     * @desc        child process binary 경로를 리턴
     * @since       0.0.1
     * @date        2019-12-30
     * @returns     {String}    child process binary 경로
    */
    get command () {
        return this._command
    }

    /**
     * @name        set:command
     * @memberof    Process
     * @function
     * @instance
     * @public
     * @desc        child process binary 경로를 세팅
     * @param       {String}    command     - child process binary 경로 constructor parameter 참조
     * @since       0.0.1
     * @date        2019-12-30
     * @see         {@link Process Process costructor}
    */
    set command (command) {
        if (typeof command === 'string') {
            this._command = command
        }
    }

    /**
     * @name        get:pid
     * @memberof    Process
     * @function
     * @instance
     * @public
     * @desc        child process pid 리턴
     * @returns     child process pid<br/>
     *              child process가 running중이지 않으면 0을 리턴
     * @since       0.0.1
     * @date        2019-12-30
    */
    get pid () {
        return this._child ? this._child.pid : 0
    }

    /**
     * @function
     * @instance
     * @public
     * @desc        child process 실행 및 life cycle 관리
     * @returns     {Promise<Process>}  child process 실행 후 this 리턴
     * @since       0.0.1
     * @date        2019-12-30
     * @fires       Process#command
     * @fires       Process#exec
     * @fires       Process#stop
     * @fires       Process#kill
     * @fires       Process#retryFail
     * @fires       Process#retry
     * @fires       Process#stderr
     * @fires       Process#stdout
     * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise}
    */
    exec () {
        let retryCnt = 0

        return this._child ? Promise.resolve(this) : exec.call(this)

        function exec () {
            return new Promise((resolve, reject) => {
                let args = this.args

                this.emit('command', [this.command].concat(args).join(' '), this)

                this._child = spawn(
                    this.command,
                    args,
                    Object.assign(
                        {
                            detached: true,
                            stdio: ['ipc', 'pipe', 'pipe']
                        },
                        this.config.env ? {env: this.config.env} : {},
                        this.config.cwd ? {cwd: this.config.cwd} : {}))
                    .on('exit', (code, signal) => {
                        let child = this._child, err
                        this._child = null

                        if (child.killed) {
                            // stop
                            this.emit(
                                'stop',
                                this,
                                new ProcessResult(child.killed, code, signal))
                        } else {
                            if (code !== DEFAULT.SUCCESS_CODE) {
                                // 비정상 종료
                                if (retryCnt < this.config.retryCnt || this.config.retryCnt === Infinity) {
                                    // 재시도
                                    if (retryCnt >= 1) {
                                        this.emit('retryFail', retryCnt, this)
                                    }

                                    this._retryTimeout = setTimeout(
                                        () => {
                                            retryCnt++
                                            this.emit('retry', retryCnt, this)
                                            exec.call(this)
                                        },
                                        this.config.retryInterval * 1000)
                                } else {
                                    // 재시도 실패
                                    err = new Error(`프로세스가 비정상 종료됐습니다 (code : ${code}, signal : ${signal})`)
                                    err.code = code
                                    err.signal = signal
                                    emitError.call(this, err, this.config.customError)
                                }
                            } else {
                                // process 정상 종료
                                this.emit(
                                    'kill',
                                    this,
                                    new ProcessResult(child.killed, code, signal))
                            }
                        }

                        removePidFile.call(this, child.pid, this.config.pidPath)
                    })
                    .on('error', err => emitError.call(this, err, this.config.customError))
                this._child.stderr.on('data', data => {
                    let stderr = data.toString()
                    this.emit('stderr', stderr, this)
                    typeof this.parseStderr === 'function' && this.parseStderr(stderr)
                })
                this._child.stdout.on('data', data => {
                    let stdout = data.toString()
                    this.emit('stdout', stdout, this)
                    typeof this.parseStdout === 'function' && this.parseStdout(stdout)
                })

                createPidFile.call(this, this._child.pid, this._command, this.config.pidPath)
                this.emit('exec', this)
                resolve(this)
            })
        }
    }

    /**
     * @function
     * @instance
     * @public
     * @desc        child process로 signal 전달
     * @param       {String}    signal  - child process로 전달할 signal
     * @since       0.0.1
     * @date        2019-12-30
    */
    kill (signal) {
        typeof signal === 'string' && this._child && this._child.kill(signal)
    }

    /**
     * @function
     * @instance
     * @public
     * @desc        child process 중지
     * @since       0.0.1
     * @date        2019-12-30
    */
    stop () {
        clearTimeout(this._retryTimeout)
        this._retryTimeout = null

        this.kill(this.config.stopSignal)
    }

    /**
     * @memberof    Process
     * @function
     * @static
     * @public
     * @desc        pid 파일 내용을 보고 process가 살아있는지 확인<br/>
     *              isRemove parameter가 true인 경우 process가 살아있지 않을 때, pid file을 삭제
     * @param       {String}                        pidFilePath         - pid file path
     * @param       {Boolean=}                      [isRemove=false]`   - true일 경우, process가 살아 있지 않으면 pid file 삭제<br/>
     *                                                                    file format이 Process class에서 정의된 포맷이 아닌 경우 Process가 생성한 pid가 아닐 수도 있으므로 삭제하지 않음
     * @returns     {Promise<CheckProcessResult>}   process가 살아있는지 여부
     * @since       0.0.1
     * @date        2019-12-30
     * @see         {@link Process~CheckProcessResult CheckProcessResult}
     * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise}
    */
    static checkProcessByPidFile (pidFilePath, isRemove) {
        return fsPromise.fileSystem.readFile(pidFilePath, 'utf8')
            .then(result => {
                let temp = result.data.split(' ').map(str => str.trim()),
                    pid = parseInt(temp.shift()),
                    command = temp.shift(),
                    err

                if (Number.isInteger(pid) && command) {
                    return Process.checkProcess(pid, command)
                        .catch(err => {
                            if (isRemove) {
                                return new Promise((resolve, reject) => fsPromise.fs.unlink(pidFilePath, _err => reject(err)))
                            } else {
                                throw err
                            }
                        })
                } else {
                    err = new Error(`invalid pid file format (pidFilePath : ${pidFilePath}, data : ${result.data})`)
                    err.pidFilePath = pidFilePath
                    err.data = result.data

                    throw err
                }
            })
    }

    /**
     * @memberof    Process
     * @function
     * @static
     * @public
     * @desc        process가 살아있는지 확인
     * @param       {Number}                        pid         - pid
     * @param       {String}                        command     - child process binary 경로
     * @returns     {Promise<CheckProcessResult>}   process가 살아있는지 여부
     * @since       0.0.1
     * @date        2019-12-30
     * @see         {@link Process~CheckProcessResult CheckProcessResult}
     * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise}
    */
    static checkProcess (pid, command) {
        return new Promise((resolve, reject) => exec(
            ['ps', '-p', pid, '-o', 'cmd', '--no-headers'].join(' '),
            (err, stdout, stderr) => {
                let _command, _args
                if (err) {
                    // process 조회가 안되면 err
                    reject(err)
                } else {
                    _args = stdout.replace(/\n$/, '').split(' ')
                    _command = _args.shift()

                    typeof command === 'string' && command !== _command ? reject(new Error(`invalid command (pid : ${pid}, command : ${command}, real command : ${_command})`)) : resolve({
                        pid: pid,
                        command: command,
                        args: _args
                    })
                }
            }))
    }

    /**
     * @memberof    Process
     * @function
     * @static
     * @public
     * @desc        전달된 pid에 해당하는 process를 kill 한다.
     * @param       {Number}            pid     - pid
     * @returns     {Promise<Number>}   pid
     * @since       0.0.1
     * @date        2019-12-30
     * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise}
    */
    static forceKillProcess (pid) {
        return Process.checkProcess(pid)
            .catch(err => pid)
            .then(result => result === pid ? pid : new Promise((resolve, reject) => exec(
                `kill -9 ${pid}`,
                (err, stdout, stderr) => err ? reject(err) : resolve(pid))))
    }

    /**
     * @memberof    Process
     * @function
     * @static
     * @public
     * @desc        전달된 pid file 내용에 해당하는 process를 kill 한다.<br/>
     *              isRemove parameter가 true인 경우 process를 kill 한 후, pid file을 삭제
     * @param       {String}                        pidFilePath         - pid file path
     * @param       {Boolean=}                      [isRemove=false]`   - true일 경우, process kill 후에 pid file 삭제
     * @returns     {Promise<String>}               pid file path
     * @since       0.0.1
     * @date        2019-12-30
     * @see         {@link Process~CheckProcessResult CheckProcessResult}
     * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise}
    */
    static forceKillProcessByPidFile (pidFilePath, isRemove) {
        return Process.checkProcessByPidFile(pidFilePath, isRemove)
            .catch(err => pidFilePath)
            .then(result => result === pidFilePath ? pidFilePath : new Promise((resolve, reject) => exec(
                `kill -9 ${result.pid}`,
                (err, stdout, stderr) => err ? reject(err) : fsPromise.fs.unlink(pidFilePath, _err => resolve(pidFilePath)))))
    }
}

/**
 * @memberof    Process
 * @function
 * @instance
 * @private
 * @desc        error 발생시, error 이벤트 또는 customError 이벤트를 발생하는 함수
 * @param       {Error}         err             - 발생한 err instance
 * @param       {Function}      customError     - config.customError
 * @since       0.0.1
 * @date        2019-12-30
 * @fires       Process#error
 * @see         {@link Process Process constructor}
*/
function emitError (err, customError) {
    let _err

    if (typeof customError === 'function' && (_err = customError.call(this, err), _err)) {
        this.emit(_err.eventName, ..._err.args)
    } else {
        this.emit('error', err, this)
    }
}

/**
 * @memberof    Process
 * @function
 * @instance
 * @private
 * @desc        child process 생성시 pid file 생성
 * @param       {Number}    pid         - pid
 * @param       {String}    command     - child process binary 경로
 * @param       {String}    pidPath     - child process 실행시 pid 파일을 생성할 directory path
 * @since       0.0.1
 * @date        2019-12-30
 * @fires       Process#createPidFile
 * @see         {@link Process Process constructor}
*/
function createPidFile (pid, command, pidPath) {
    let pidFilePath

    if (typeof pidPath === 'string') {
        try {
            pidFilePath = getPidFilePath(pid, pidPath)

            fsPromise.fileSystem.mkdir(pidPath)
                .then(() => fsPromise.fileSystem.writeFile(pidFilePath, `${pid} ${command}`)
                    .then(() => this.emit('createPidFile', pidFilePath, this)))
                .catch(err => this.emit('createPidFile', pidFilePath, this, err))
        } catch (err) {
            this.emit('createPidFile', pidFilePath, this, err)
        }
    }
}

/**
 * @memberof    Process
 * @function
 * @instance
 * @private
 * @desc        child process 종료시 pid file 제거
 * @param       {Number}    pid         - pid
 * @param       {String}    pidPath     - child process 실행시 pid 파일을 생성할 directory path
 * @since       0.0.1
 * @date        2019-12-30
 * @fires       Process#removePidFile
 * @see         {@link Process Process constructor}
*/
function removePidFile (pid, pidPath) {
    let pidFilePath

    if (typeof pidPath === 'string') {
        try {
            pidFilePath = getPidFilePath(pid, pidPath)

            fsPromise.fileSystem.checkPath(pidFilePath)
                .catch(() => new Promise(resolve => setTimeout(() => resolve(), 1000)))     // pid file write 되기 전에 process down되서 remove 되는 경우 1초 timeout 을 주고 삭제 시도
                .then(() => {
                    fsPromise.fs.unlink(pidFilePath, err => this.emit('removePidFile', pidFilePath, this, err))
                })
                .catch(err => {
                    this.emit('removePidFile', pidFilePath, this, err)
                })
        } catch (err) {
            this.emit('removePidFile', pidFilePath, this, err)
        }
    }
}

/**
 * @memberof    Process
 * @function
 * @instance
 * @private
 * @desc        pid 파일 경로를 리턴
 * @param       {Number}    pid         - pid
 * @param       {String}    pidPath     - child process 실행시 pid 파일을 생성할 directory path
 * @since       0.0.1
 * @date        2019-12-30
 * @see         {@link Process Process constructor}
*/
function getPidFilePath (pid, pidPath) {
    return path.join(pidPath, `${pid}.pid`)
}

module.exports = exports = Process
