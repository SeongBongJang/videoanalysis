'use strict'


/** Events **/
/**
 * @event       WorkerContainer#workerExec
 * @desc        worker가 job 실행시 발생하는 이벤트
 * @param       {Job}               job                 작업을 실행한 Job instance
 * @param       {Worker}            worker              작업을 실행한 Worker instance
 * @param       {WorkerContainer}   WorkerContainer     이벤트가 발생한 WorkerContainer instance
*/
/**
 * @event       WorkerContainer#workerStop
 * @desc        worker가 job 실행 중지시 발생하는 이벤트
 * @param       {Job}               job                 작업을 중지한 Job instance
 * @param       {Worker}            worker              작업을 중지한 Worker instance
 * @param       {WorkerContainer}   WorkerContainer     이벤트가 발생한 WorkerContainer instance
*/
/**
 * @event       WorkerContainer#workerEnd
 * @desc        worker가 job 종료시 발생하는 이벤트
 * @param       {Job}               job                 작업을 종료한 Job instance
 * @param       {Worker}            worker              작업을 종료한 Worker instance
 * @param       {WorkerContainer}   WorkerContainer     이벤트가 발생한 WorkerContainer instance
*/
/**
 * @event       WorkerContainer#workerError
 * @desc        job 실행 실패시 발생하는 이벤트
 * @param       {Error}             err                 Error instance
 * @param       {Job}               job                 작업을 실패한 Job instance
 * @param       {Worker}            worker              작업을 실패한 Worker instance
 * @param       {WorkerContainer}   WorkerContainer     이벤트가 발생한 WorkerContainer instance
*/
/**
 * @event       WorkerContainer#execError
 * @desc        job 실행 실패시 발생하는 이벤트
 * @param       {Error}             err                 Error instance
 * @param       {Job}               job                 실행을 실패한 Job
 * @param       {WorkerContainer}   WorkerContainer     이벤트가 발생한 WorkerContainer instance
*/
const utils = require('@amuzlab/utils'),
    uuidv1 = require('uuid/v1'),

    workerFactory = require('./WorkerFactory')

/**
 * @class       WorkerContainer
 * @classdesc   비즈니스 로직을 처리하는 Worker들의 동시처리 개수를 조절하고 job queue를 관리
 * @extends     events
 * @param       {Object=}                       config                              Worker 설정 정보
 * @param       {Number|Function|Infinity=}     [config.maxWorkerCount=1]           최대 동시처리 개수
 *                                                                                  <ul>
 *                                                                                    <li>Number   : 최대 동시처리 개수</li>
 *                                                                                    <li>Function : 최대 동시처리 개수를 정할 수 있는 콜백 함수 true를 리턴하면 실행, false를 리턴하면 실행하지 않고 ready qeueu에 대기</li>
 *                                                                                    <li>Infinity : 동시처리 개수 제한 없음</li>
 *                                                                                  </ul>
 * @param       {Boolean=}                      [config.autoGenerateJobId=false]    job ID 자동 생성 (UUID)<br/>
 * @since       1.0.0
 * @date        2020-01-22
*/
class WorkerContainer extends require('events') {
    constructor(config) {
        super()

        Object.defineProperties(
            this,
            {
                _config: {
                    writable: true,
                    value: ((config) => {
                        !config && (config = {})

                        !/(number|function)/i.test(typeof config.maxWorkerCount) && (config.maxWorkerCount = 1)
                        !/boolean/i.test(typeof config.autoGenerateJobId) && (config.autoGenerateJobId = false)
                        !/(number|boolean)/i.test(typeof config.scheduling) && (config.scheduling = false)

                        return config
                    })(config)
                },
                /**
                 * @name        _readyQueue
                 * @memberof    WorkerContainer
                 * @desc        대기 중인 작업 큐
                 * @type        {Array<Job>}
                 * @instance
                 * @private
                 * @since       1.0.0
                 * @date        2020-01-22
                */
                _readyQueue: {
                    writable: true,
                    value: []
                },
                /**
                 * @name        _workers
                 * @memberof    WorkerContainer
                 * @desc        작업 중인 Worker 리스트
                 * @type        {Array<Worker>}
                 * @instance
                 * @private
                 * @since       1.0.0
                 * @date        2020-01-22
                */
                _workers: {
                    writable: true,
                    value: []
                }
            })
        if (this.config.scheduling) {
            workerScheduler.call(this)
        }
    }

    /**
     * @name        get:config
     * @memberof    WorkerContainer
     * @desc        Worker 설정 리턴
     * @function
     * @instance
     * @public
     * @returns     {Object}    config
     * @since       1.0.0
     * @date        2020-01-22
     * @see         {@link WorkerContainer WorkerContainer constructor}
    */
    get config() {
        return this._config
    }

    /**
     * @name        set:config
     * @memberof    WorkerContainer
     * @desc        Worker 설정 세팅
     * @function
     * @instance
     * @public
     * @param       {Object}                        config
     * @param       {Number|Function|Infinity=}     [config.maxWorkerCount=1]   최대 동시처리 개수
     *                                                                          <ul>
     *                                                                            <li>Number   : 최대 동시처리 개수</li>
     *                                                                            <li>Function : 최대 동시처리 개수를 정할 수 있는 콜백 함수 true를 리턴하면 실행, false를 리턴하면 실행하지 않고 ready qeueu에 대기</li>
     *                                                                            <li>Infinity : 동시처리 개수 제한 없음</li>
     *                                                                          </ul>
     * @since       1.0.0
     * @date        2020-01-22
     * @see         {@link WorkerContainer WorkerContainer constructor}
    */
    set config(config) {
        config && Object.assign(this.config, config)
    }

    /**
     * @name        get:readyQueue
     * @memberof    WorkerContainer
     * @desc        job ready queue 리턴
     * @function
     * @instance
     * @public
     * @returns     {Array<Job>} ready queue
     * @since       1.0.0
     * @date        2020-01-22
    */
    get readyQueue() {
        return this._readyQueue
    }

    /**
     * @name        get:workers
     * @memberof    WorkerContainer
     * @desc        현재 실행중인 worker 리스트 리턴
     * @function
     * @instance
     * @public
     * @returns     {Array<Worker>} execute worker list
     * @since       1.0.0
     * @date        2020-01-22
    */
    get workers() {
        return this._workers
    }

    /**
     * @name        get:execQueue
     * @memberof    WorkerContainer
     * @desc        현재 실행중인 job 리스트 리턴
     * @function
     * @instance
     * @public
     * @returns     {Array} execute job list
     * @since       1.0.0
     * @date        2020-01-22
    */
    get execQueue() {
        return utils.map(this.workers, worker => worker.job)
    }

    /**
     * @name        exec
     * @memberof    WorkerContainer
     * @desc        job 실행. config.autoGenerateJobId가 true인 경우 job.id를 내부적으로 생성하여 할당
     * @function
     * @instance
     * @public
     * @param       {Job}       job     실행할 작업 데이터
     * @returns     {String}    config.autoGenerateJobId가 true인 경우 생성된 job.id 리턴. false인 경우 job에 세팅된 job.id 리턴
     * @throws      {Error}     전달된 job이 없음
     * @since       1.0.0
     * @date        2020-01-22
    */
    exec(job) {
        let id

        if (job) {
            this.config.autoGenerateJobId && (id = uuidv1(), job.id = id)
            
            if (!this.config.scheduling) {     
                isExecutable(this) ? execWorker(job, this) : (this.readyQueue.push(job), this.readyQueue.sort((job1, job2) => job1.priority - job2.priority))
            } else {
                this.readyQueue.push(job)
                this.readyQueue.sort((job1, job2) => job1.priority - job2.priority)
            }

            return job.id
        } else {
            throw new Error('does not exist job parameter')
        }
    }

    /**
     * @name        cancel
     * @memberof    WorkerContainer
     * @desc        job 취소
     * @function
     * @instance
     * @public
     * @param       {Number|String|Function|Symbol}     id      취소할 작업 판단 기준
     *                                                  <ul>
     *                                                    <li>Function       : Job instance를 parameter로 한 callback function. true를 리턴한 job은 취소 대상</li>
     *                                                    <li>Number, String : Job.id와 동일한 값</li>
     *                                                    <li>Symbol
     *                                                      <ul>
     *                                                        <li>Symbol.for('amuzlab.worker.cancel.ALL')   : 모든 job 취소</li>
     *                                                        <li>Symbol.for('amuzlab.worker.cancel.READY') : 대기중인 모든 job 취소</li>
     *                                                      </ul>
     *                                                    </li>
     *                                                  </ul>
     * @returns     {Array<Job>}    취소된 작업 리스트
     * @since       1.0.0
     * @date        2020-01-28
    */
    cancel(id) {
        let jobs = []

        if (arguments.length === 0) throw new Error('does not exist id parameter')

        switch (true) {
            case typeof id === 'function':
                jobs = _cancelReadyQueue.call(this, id)
                jobs.splice(0, 0, ..._cancelExecQueue.call(this, id))
                break
            case typeof id === 'symbol':
                switch (id) {
                    case Symbol.for('amuzlab.worker.cancel.ALL'):
                        // 전체 cancel
                        jobs = _cancelReadyQueue.call(this, () => true)
                        jobs.splice(0, 0, ..._cancelExecQueue.call(this, () => true))
                        break
                    case Symbol.for('amuzlab.worker.cancel.READY'):
                        // ready queue cancel
                        jobs = _cancelReadyQueue.call(this, () => true)
                        break
                }

                break
            default:
                jobs = _cancelReadyQueue.call(this, job => job.id === id)
                jobs.splice(0, 0, ..._cancelExecQueue.call(this, job => job.id === id))
        }

        function _cancelReadyQueue(callback) {
            let jobs = []

            this._readyQueue = utils.filter(
                this.readyQueue,
                (job, index, readyQueue) => callback(job, index, this) ? (jobs.push(job), false) : true)

            return jobs
        }

        function _cancelExecQueue(callback) {
            let jobs = [],
                _workers = []

            this._workers = utils.filter(
                this.workers,
                (worker, index, workers) => callback(worker.job, index, this) ? (jobs.push(worker.job), _workers.push(worker), false) : true)

            utils.forEach(_workers, worker => worker.stop())

            return jobs
        }

        return jobs
    }
}

module.exports = exports = WorkerContainer

/**
 * @name        isExecutable
 * @memberof    WorkerContainer
 * @desc        현재 job을 실행가능한 상환인지 판단하여 Boolean 값 리턴<br/>
 *              판단 기준은 config.maxWorkerCount를 따름
 * @function
 * @private
 * @static
 * @param       {WorkerContainer}   workerContainer     workerContainer instance
 * @returns     {Boolean}   실행 가능 여부
 * @since       1.0.0
 * @date        2020-01-28
 * @see         {@link WorkerContainer WorkerContainer constructor}
*/
function isExecutable(workerContainer) {
    let callback

    switch (true) {
        case typeof workerContainer.config.maxWorkerCount === 'number':
            callback = () => workerContainer.workers.length < workerContainer.config.maxWorkerCount
            break
        case typeof workerContainer.config.maxWorkerCount === 'function':            
            callback = workerContainer.config.maxWorkerCount
            break
        default:
    }

    return callback(workerContainer)
}

/**
 * @name        execWorker
 * @memberof    WorkerContainer
 * @desc        WorkerFactory에서 리턴된 job.serviceType에 맞는 Worker에 job을 세팅하고 실행. execQueue에 inqueue<br/>
 *              미리 정의된 event에 의해 queue로 관리<br/>
 *              작업 종료 및 실패시, 해당 Worker는 execQueue 에서 제외되고 다음 job을 실행할 Worker를 실행<br/>
 *              events
 *              <ul>
 *                <li>end : 작업 종료</li>
 *                <li>error : 작업 실패</li>
 *              </ul>
 * @function
 * @private
 * @static
 * @param       {Job}               job                 실행할 작업
 * @param       {WorkerContainer}   workerContainer     workerContainer instance
 * @fires       WorkerContainer#workerExec
 * @fires       WorkerContainer#workerStop
 * @fires       WorkerContainer#workerEnd
 * @fires       WorkerContainer#workerError
 * @fires       WorkerContainer#execError
 * @since       1.0.0
 * @date        2020-01-28
*/
function execWorker(job, workerContainer) {
    let worker

    try {
        worker = workerFactory.getWorker(job)
        workerContainer.workers.push(worker)
        worker.job = job
        worker
            .on('exec', (job, worker) => workerContainer.emit('workerExec', job, worker, workerContainer))
            .on('end', (job, worker) => {
                workerContainer.emit('workerEnd', job, worker, workerContainer)
                workerContainer.config.scheduling ? _removeWorker(worker, workerContainer) : _next(worker, workerContainer)
            })
            .on('stop', (job, worker) => {
                workerContainer.emit('workerStop', job, worker, workerContainer)
                workerContainer.config.scheduling ? _removeWorker(worker, workerContainer) : _next(worker, workerContainer)
            })
            .on('error', (err, job, worker) => {                
                workerContainer.emit('workerError', err, job, worker, workerContainer)
                workerContainer.config.scheduling ? _removeWorker(worker, workerContainer) : _next(worker, workerContainer)
            })
            .exec()


    } catch (err) {
        workerContainer.emit('execError', err, job, workerContainer)
        _isExecutable(workerContainer) && execWorker(workerContainer.readyQueue.shift(), workerContainer)
    }

    function _next(worker, workerContainer) {
        _removeWorker(worker, workerContainer)
        _isExecutable(workerContainer) && execWorker(workerContainer.readyQueue.shift(), workerContainer)
    }

    function _removeWorker(worker, workerContainer) {
        workerContainer.workers.some((_worker, _index) => _worker === worker && (workerContainer.workers.splice(_index, 1), true))
    }

    function _isExecutable(workerContainer) {
        return workerContainer.readyQueue.length > 0 && isExecutable(workerContainer)
    }
}

async function workerScheduler() {    
    await new Promise(resolve => setTimeout(resolve, this.config.scheduling));
    
    if (await isExecutable(this)) {        
        execWorker(this.readyQueue.shift(), this)
    }

    workerScheduler.call(this)
}